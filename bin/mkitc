#!/usr/bin/env ruby
# frozen_string_literal: true

require 'rubygems'
require 'optparse'
require 'yaml'
require 'net/http'
require 'json'
require 'net_http_unix'
require 'securerandom'
require 'erb'

class MKItClient

  def initialize
    @client = NetX::HTTPUnix.new("localhost",4567)
  end

  def dict
    global_args = [
      {  short: "-v", long: "--verbose", help: "verbose", mandatory: false, value: nil }
    ]
    command_dict = [
      {
        cmd: 'ps',
        args: [
          { name: 'id', mandatory: false, path: '/<%=id%>' }
        ],
        help: 'show services status [service_id_or_name]',
        request: { verb: :get, uri: '/services', params: [:id]},
      },
      {
        cmd: 'status',
        args: [
          { name: 'id', mandatory: false, path: '/<%=id%>' }
        ],
        help: 'show services status [service_id_or_name]',
        request: { verb: :get, uri: '/services', params: [:id]},
      },
      {
        cmd: 'start',
        args: [
          { name: 'id', mandatory: true }
        ],
        help: 'start service <service_id|service_name>',
        request: { verb: :put, uri: '/services/<%=id%>/start', params: [:id]},
      },
      {
        cmd: 'stop',
        args: [
          { name: 'id', mandatory: true }
        ],
        help: 'stop service <service_id|service_name>',
        request: { verb: :put, uri: '/services/<%=id%>/stop', params: [:id]},
      },
      {
        cmd: 'restart',
        args: [
          { name: 'id', mandatory: true }
        ],
        help: 'restart service <service_id|service_name>',
        request: { verb: :put, uri: '/services/<%=id%>/restart', params: [:id]},
      },
      {
        cmd: 'create',
        args: [
          { name: 'file', mandatory: true }
        ],
        help: 'create service <service.yaml>',
        request: { verb: :post, uri: '/services', file: [:file]},
      },
      {
        cmd: 'update',
        args: [
          { name: 'file', mandatory: true }
        ],
        help: 'update service <service.yaml>',
        request: { verb: :put, uri: '/services', file: [:file]},
      },
      {
        cmd: 'version',
        help: 'prints mkit version',
        request: { verb: :get, uri: '/mkit/version'},
      },
      {
        cmd: 'proxy',
        options: [
          {
            cmd: 'start',
            request: { verb: :put, uri: '/mkit/proxy/start'},
            help: 'start proxy service',
          },
          {
            cmd: 'stop',
            request: { verb: :put, uri: '/mkit/proxy/stop'},
            help: 'stop proxy service',
          },
          {
            cmd: 'status',
            request: { verb: :get, uri: '/mkit/proxy/status'},
            help: 'proxy service status',
          },
        ],
        help: 'proxy status and control',
      },
    ]
#    @command_dict << 
#      {
#        cmd: 'help',
#        help: 'Usage',
#        options: @command_dict.each { |c| { cmd: c.cmd } }.map.to_a
#      }
    command_dict
  end

  def help(cmd = nil)
     puts "help [#{cmd}]"
  end

  def create(request, request_hash = nil)
    puts "CREATE CALLED #{request} - #{request_hash}"
  end

  def update (request, request_hash = nil)
    yaml = YAML.load_file(request_hash[:file])
    if yaml["service"].nil?
      raise 'update: invalid configuration file'
    else
      id = yaml["service"]["name"]
      request_hash[:id] = id
      request({ verb: :put, uri: "/services/<%=id%>" }, request_hash)
    end
  end

  def parse_args(args)
    schema = dict.dup
    cmd = args[0]
    c = schema.select{ |k| k[:cmd] == cmd}.first
    return help if c.nil?

    myargs = args.dup
    myargs.delete(cmd)

    max_args_size = c[:args].nil? ? 0 : c[:args].size
    max_options_size = c[:options].nil? ? 0 : 1
    max_args_size = max_args_size + max_options_size

    min_args_size = c[:args].nil? ? 0 : c[:args].select{|a| a[:mandatory] == true}.size
    min_options_size = c[:options].nil? ? 0 : 1
    min_args_size = min_args_size + min_options_size

    return help(c) if myargs.size > max_args_size || myargs.size < min_args_size

    request_hash = {}
    request = c[:request]
    #
    if myargs.size > 0
      unless c[:args].nil?
        idx = 0
        c[:args].each { |a|
          request_hash[a[:name]] = myargs[idx]
          idx+=1
        }
      end
      # options
      unless c[:options].nil?
        option = nil
        myargs.each{ |s|
          option = c[:options].select{ |o| o[:cmd] == s}.first
          puts "#{option} <- #{s}"
          return help(c) if option.nil? || option.empty?
        }
        return help(c) if option.nil? || option.empty?
        request = option[:request]
      end
    end
    return help if request.nil?

    if self.respond_to?c[:cmd]
      self.send(c[:cmd], request, request_hash)
    else
      request(request,request_hash)
    end
  end

  def doIt(args)
    result = parse_args(args)
    puts result
  end

  def request(request, request_args = nil)
    req = nil
    uri = ERB.new(request[:uri]).result_with_hash(request_args)
    request[:file] = request_args[:file]

    case request[:verb]
    when :post
      req = Net::HTTP::Post.new(uri)
      unless request[:file].nil?
        (body, boundary) = attach(request[:file])
        req.body = body
        req["Content-Type"] = "multipart/form-data, boundary=#{boundary}"
      end
    when :put
      req = Net::HTTP::Put.new(uri)
      unless request[:file].nil?
        (body, boundary) = attach(request[:file])
        req.body = body
        req["Content-Type"] = "multipart/form-data, boundary=#{boundary}"
      end
    when :patch
      req = Net::HTTP::Patch.new(uri)
    when :get
      req = Net::HTTP::Get.new(uri)
    when :delete
      req = Net::HTTP::Delete.new(uri)
    end
    @client.request(req).body
  end

  def attach(file)
    boundary=SecureRandom.alphanumeric
    body = []
    body << "--#{boundary}\r\n"
    body << "Content-Disposition: form-data; name=file; filename='#{File.basename(file)}'\r\n"
    body << "Content-Type: text/plain\r\n"
    body << "\r\n"
    body << File.read(file)
    body << "\r\n--#{boundary}--\r\n"
    [ body.join, boundary]
  end
end

#
# go
#
client = MKItClient.new
client.doIt(ARGV.dup)
#
# if ARGV.any?
# parse args
#  host, socket, config file
# end

