#!/usr/bin/env ruby
# frozen_string_literal: true

require 'rubygems'
require 'optparse'
require 'yaml'
require 'net/http'
require 'json'
require 'net_http_unix'
require 'securerandom'
require 'erb'

class MKItClient

  def initialize
    @client = NetX::HTTPUnix.new("localhost",4567)
  end

  def dict
    global_args = [
      {  short: "-v", long: "--verbose", help: "verbose", mandatory: false, value: nil }
    ]
    command_dict = [
      {
        cmd: 'ps',
        args: [
          { name: 'id', mandatory: false, path: '/<%=id%>' }
        ],
        help: 'show services status [service_id_or_name]',
        request: { verb: :get, uri: '/services', params: [:id]},
      },
      {
        cmd: 'status',
        args: [
          { name: 'id', mandatory: false, path: '/<%=id%>' }
        ],
        help: 'show services status [service_id_or_name]',
        request: { verb: :get, uri: '/services', params: [:id]},
      },
      {
        cmd: 'start',
        args: [
          { name: 'id', mandatory: true }
        ],
        help: 'start service <service_id|service_name>',
        request: { verb: :put, uri: '/services/<%=id%>/start', params: [:id]},
      },
      {
        cmd: 'stop',
        args: [
          { name: 'id', mandatory: true }
        ],
        help: 'stop service <service_id|service_name>',
        request: { verb: :put, uri: '/services/<%=id%>/stop', params: [:id]},
      },
      {
        cmd: 'restart',
        args: [
          { name: 'id', mandatory: true }
        ],
        help: 'restart service <service_id|service_name>',
        request: { verb: :put, uri: '/services/<%=id%>/restart', params: [:id]},
      },
      {
        cmd: 'create',
        args: [
          { name: 'file', mandatory: true }
        ],
        help: 'create service <service.yaml>',
        request: { verb: :post, uri: '/services', file: [:file]},
      },
      {
        cmd: 'update',
        args: [
          { name: 'file', mandatory: true }
        ],
        help: 'update service <service.yaml>',
        request: { verb: :put, uri: '/services', file: [:file]},
      },
      {
        cmd: 'version',
        help: 'prints mkit version',
        request: { verb: :get, uri: '/mkit/version'},
      },
      {
        cmd: 'proxy',
        options: [
          {
            cmd: 'start',
            request: { verb: :put, uri: '/mkit/proxy/start'},
            help: 'start proxy service',
          },
          {
            cmd: 'stop',
            request: { verb: :put, uri: '/mkit/proxy/stop'},
            help: 'stop proxy service',
          },
          {
            cmd: 'status',
            request: { verb: :get, uri: '/mkit/proxy/status'},
            help: 'proxy service status',
          },
        ],
        help: 'proxy status and control',
      },
    ]
#    @command_dict << 
#      {
#        cmd: 'help',
#        help: 'Usage',
#        options: @command_dict.each { |c| { cmd: c.cmd } }.map.to_a
#      }
    command_dict
  end

  def help(cmd = nil)
     puts "help [#{cmd}]"
  end

  def create(request, request_hash = nil)
    puts "CREATE CALLED #{request} - #{request_hash}"
  end

  def parse_args_2(args)
    schema = dict.dup
    cmd = args[0]
    c = schema.select{ |k| k[:cmd] == cmd}.first
    return help if c.nil?

    myargs = args.dup
    myargs.delete(cmd)

    puts "command #{cmd} #{c}"

    max_args_size = c[:args].nil? ? 0 : c[:args].size
    max_options_size = c[:options].nil? ? 0 : 1
    max_args_size = max_args_size + max_options_size

    min_args_size = c[:args].nil? ? 0 : c[:args].select{|a| a[:mandatory] == true}.size
    min_options_size = c[:options].nil? ? 0 : 1
    min_args_size = min_args_size + min_options_size

    return help(c) if myargs.size > max_args_size || myargs.size < min_args_size

    request_hash = {}
    request = c[:request]
    #
    if myargs.size > 0
      unless c[:args].nil?
        idx = 0
        c[:args].each { |a|
          request_hash[a[:name]] = myargs[idx]
          idx+=1
        }
      end
      # options
      unless c[:options].nil?
        option = nil
        myargs.each{ |s|
          option = c[:options].select{ |o| o[:cmd] == s}.first
          puts "#{option} <- #{s}"
          return help(c) if option.nil? || option.empty?
        }
        return help(c) if option.nil? || option.empty?
        request = option[:request]
      end
    end
    return help if request.nil?

    puts request
    puts request_hash
    if self.respond_to?c[:cmd]
       self.send(c[:cmd], request, request_hash)
    end
#    request[:uri] =ERB.new(request[:uri]).result_with_hash(request_hash)
#    request
  end

  def parse_args(args)
    request = nil
    case args[0]
    when /^ps$/
      if args.include?('-v')
        params = {verbose: 'true'}
        args.delete('-v')
      else
        params = {}
      end
      case args.size
      when 1
        #mkitc ps [-v] GET services[?verbose=true]
        request = { verb: :get, uri: '/services', params: params }
      when 2
        #mkitc ps <%=id%> GET services/<%=id%>
        id = args[1]
        request = { verb: :get, uri: "/services/#<%=id%>" }
      else
        raise 'invalid parameters'
      end
    when /^config:show$/
      #mkitc config:show <%=id%> => GET services/<%=id%>/config
      #TODO
    when /^stop$/
      #mkitc stop  <%=id%> => PUT services/<%=id%>/stop
      case args.size
      when 2
        id = args[1]
        request = { verb: :put, uri: "/services/#<%=id%>/stop" }
      else
        raise 'stop: invalid parameters'
      end
    when /^start$/
      #mkitc start <%=id%> => PUT services/<%=id%>/start
      case args.size
      when 2
        id = args[1]
        request = { verb: :put, uri: "/services/#<%=id%>/start" }
      else
        raise 'start: invalid parameters'
      end
    when /^restart$/
      #mkitc restart <%=id%> => PUT services/<%=id%>/restart
      case args.size
      when 2
        id = args[1]
        request = { verb: :put, uri: "/services/#<%=id%>/restart" }
      else
        raise 'restart: invalid parameters'
      end
    when /^rm$/
      #mkitc rm <%=id%> => DELETE services/<%=id%>
      case args.size
      when 2
        id = args[1]
        request = { verb: :delete, uri: "/services/#<%=id%>" }
      else
        raise 'rm: invalid parameters'
      end
    when /^create$/
      #mkitc create service.yaml => POST services service.yaml
      case args.size
      when 2
        file = args[1]
        request = { verb: :post, uri: "/services", file: file }
      else
        raise 'create: invalid parameters'
      end
    when /^update$/
      #mkitc update service.yaml => PUT services/<%=id%> service.yaml
      case args.size
      when 2
        file = args[1]
        yaml = YAML.load_file(file)
        if yaml["service"].nil?
          raise 'update: invalid configuration file'
        else
          id = yaml["service"]["name"]
          request = { verb: :put, uri: "/services/#{id}", file: file }
        end
      else
        raise 'update: invalid parameters'
      end
    when /^version$/
      #mkitc version
      request = { verb: :get, uri: "/mkit/version" }
    when /^proxy$/
      #mkitc proxy restart
      request = { verb: :get, uri: "/mkit/version" }
      case args.size
      when 2
        cmd = args[1]
        case cmd
        when /^status$/
          request = { verb: :get, uri: "/mkit/proxy/status"}
        when /^restart$/
          request = { verb: :put, uri: "/mkit/proxy/restart"}
        else
          raise 'invalid proxy parameters'
        end
      else
        raise 'invalid proxy parameters'
      end
    else
      raise "Usage: invalid parameters"
    end
    request
  end

  def doIt(args)
    operation = parse_args(args)
    puts request(operation).body
  end

  def request(request)
    req = nil
    uri = request[:uri]
    unless request[:params].nil? || request[:params].empty?
      uri = uri + '?' + request[:params].map{|k,v| "#{k}=#{v}"}.join('&')
    end
    case request[:verb]
    when :post
      req = Net::HTTP::Post.new(uri)
      unless request[:file].nil?
        (body, boundary) = attach(request[:file])
        req.body = body
        req["Content-Type"] = "multipart/form-data, boundary=#{boundary}"
      end
    when :put
      req = Net::HTTP::Put.new(uri)
      unless request[:file].nil?
        (body, boundary) = attach(request[:file])
        req.body = body
        req["Content-Type"] = "multipart/form-data, boundary=#{boundary}"
      end
    when :patch
      req = Net::HTTP::Patch.new(uri)
    when :get
      req = Net::HTTP::Get.new(uri)
    when :delete
      req = Net::HTTP::Delete.new(uri)
    end
    @client.request(req)
  end

  def attach(file)
    boundary=SecureRandom.alphanumeric
    body = []
    body << "--#{boundary}\r\n"
    body << "Content-Disposition: form-data; name=file; filename='#{File.basename(file)}'\r\n"
    body << "Content-Type: text/plain\r\n"
    body << "\r\n"
    body << File.read(file)
    body << "\r\n--#{boundary}--\r\n"
    [ body.join, boundary]
  end
end

#
# go
#
client = MKItClient.new
client.doIt(ARGV.dup)
#
# if ARGV.any?
# parse args
#  host, socket, config file
# end

